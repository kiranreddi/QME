//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant UVM V4.4 (Build 1)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : registers
// Unit            : uart1650_registers_pkg
// File            : uart1650_registers_pkg.sv
//----------------------------------------------------------------------
// Created by      : mikaela
// Creation Date   : 6/19/14 11:48 AM
//----------------------------------------------------------------------
// Title           : registers
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// uart1650_registers_pkg
//----------------------------------------------------------------------
package uart1650_registers_pkg;

   import uvm_pkg::*;

   `include "uvm_macros.svh"

   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: IER_reg
   // 
   //--------------------------------------------------------------------

   class IER_reg extends uvm_reg;
      `uvm_object_utils(IER_reg)

      uvm_reg_field RESERVED; 
      rand uvm_reg_field MODSTAT_ENA; 
      rand uvm_reg_field RXSTAT_ENA; 
      rand uvm_reg_field TXEMTPTY_ENA; 
      rand uvm_reg_field RXDAT_ENA; 


      // Function: new
      // 
      function new(string name = "IER_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         RESERVED = uvm_reg_field::type_id::create("RESERVED");
         MODSTAT_ENA = uvm_reg_field::type_id::create("MODSTAT_ENA");
         RXSTAT_ENA = uvm_reg_field::type_id::create("RXSTAT_ENA");
         TXEMTPTY_ENA = uvm_reg_field::type_id::create("TXEMTPTY_ENA");
         RXDAT_ENA = uvm_reg_field::type_id::create("RXDAT_ENA");

         RESERVED.configure(this, 4, 7, "RW", 0, 4'h0, 0, 0, 0);
         MODSTAT_ENA.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         RXSTAT_ENA.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         TXEMTPTY_ENA.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         RXDAT_ENA.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: LCR_reg
   // 
   //--------------------------------------------------------------------

   class LCR_reg extends uvm_reg;
      `uvm_object_utils(LCR_reg)

      rand uvm_reg_field SET_DIV_LATCH_ACCESS; 
      rand uvm_reg_field SET_BREAK_CONTROL; 
      rand uvm_reg_field SET_STICKY_PARITY; 
      rand uvm_reg_field SET_EVEN_PARITY; 
      rand uvm_reg_field PARITY_ENA; 
      rand uvm_reg_field SET_NO_OF_STOPBITS; 
      rand uvm_reg_field SET_NO_OF_BITS; 


      // Function: new
      // 
      function new(string name = "LCR_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         SET_DIV_LATCH_ACCESS = uvm_reg_field::type_id::create("SET_DIV_LATCH_ACCESS");
         SET_BREAK_CONTROL = uvm_reg_field::type_id::create("SET_BREAK_CONTROL");
         SET_STICKY_PARITY = uvm_reg_field::type_id::create("SET_STICKY_PARITY");
         SET_EVEN_PARITY = uvm_reg_field::type_id::create("SET_EVEN_PARITY");
         PARITY_ENA = uvm_reg_field::type_id::create("PARITY_ENA");
         SET_NO_OF_STOPBITS = uvm_reg_field::type_id::create("SET_NO_OF_STOPBITS");
         SET_NO_OF_BITS = uvm_reg_field::type_id::create("SET_NO_OF_BITS");

         SET_DIV_LATCH_ACCESS.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         SET_BREAK_CONTROL.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         SET_STICKY_PARITY.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         SET_EVEN_PARITY.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         PARITY_ENA.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         SET_NO_OF_STOPBITS.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         SET_NO_OF_BITS.configure(this, 2, 0, "RW", 0, 2'b11, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: MSR_reg
   // 
   //--------------------------------------------------------------------

   class MSR_reg extends uvm_reg;
      `uvm_object_utils(MSR_reg)

      uvm_reg_field DCD_COMP; 
      uvm_reg_field RI_COMP; 
      uvm_reg_field DSR_COMP; 
      uvm_reg_field CTS_COMP; 
      uvm_reg_field DDCD; 
      uvm_reg_field TERI; 
      uvm_reg_field DDSR; 
      uvm_reg_field DCTS; 


      // Function: new
      // 
      function new(string name = "MSR_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         DCD_COMP = uvm_reg_field::type_id::create("DCD_COMP");
         RI_COMP = uvm_reg_field::type_id::create("RI_COMP");
         DSR_COMP = uvm_reg_field::type_id::create("DSR_COMP");
         CTS_COMP = uvm_reg_field::type_id::create("CTS_COMP");
         DDCD = uvm_reg_field::type_id::create("DDCD");
         TERI = uvm_reg_field::type_id::create("TERI");
         DDSR = uvm_reg_field::type_id::create("DDSR");
         DCTS = uvm_reg_field::type_id::create("DCTS");

         DCD_COMP.configure(this, 1, 7, "RO", 0, 1'b0, 0, 0, 0);
         RI_COMP.configure(this, 1, 6, "RO", 0, 1'b0, 0, 0, 0);
         DSR_COMP.configure(this, 1, 5, "RO", 0, 1'b0, 0, 0, 0);
         CTS_COMP.configure(this, 1, 4, "RO", 0, 1'b0, 0, 0, 0);
         DDCD.configure(this, 1, 3, "RO", 0, 1'b0, 0, 0, 0);
         TERI.configure(this, 1, 2, "RO", 0, 1'b0, 0, 0, 0);
         DDSR.configure(this, 1, 1, "RO", 0, 1'b0, 0, 0, 0);
         DCTS.configure(this, 1, 0, "RO", 0, 1'b0, 0, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: FCR_reg
   // 
   //--------------------------------------------------------------------

   class FCR_reg extends uvm_reg;
      `uvm_object_utils(FCR_reg)

      rand uvm_reg_field SET_RX_IRQ_LEVEL; 
      rand uvm_reg_field CLEAR_TX_FIFO; 
      rand uvm_reg_field CLEAR_RX_FIFO; 


      // Function: new
      // 
      function new(string name = "FCR_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         SET_RX_IRQ_LEVEL = uvm_reg_field::type_id::create("SET_RX_IRQ_LEVEL");
         CLEAR_TX_FIFO = uvm_reg_field::type_id::create("CLEAR_TX_FIFO");
         CLEAR_RX_FIFO = uvm_reg_field::type_id::create("CLEAR_RX_FIFO");

         SET_RX_IRQ_LEVEL.configure(this, 2, 7, "WO", 0, 2'b00, 0, 1, 0);
         CLEAR_TX_FIFO.configure(this, 1, 2, "WO", 0, 1'b0, 0, 1, 0);
         CLEAR_RX_FIFO.configure(this, 1, 1, "WO", 0, 1'b0, 0, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: MCR_reg
   // 
   //--------------------------------------------------------------------

   class MCR_reg extends uvm_reg;
      `uvm_object_utils(MCR_reg)

      rand uvm_reg_field LOOPBACK; 
      rand uvm_reg_field DCD; 
      rand uvm_reg_field RI; 
      rand uvm_reg_field RTS; 
      rand uvm_reg_field DTR; 


      // Function: new
      // 
      function new(string name = "MCR_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         LOOPBACK = uvm_reg_field::type_id::create("LOOPBACK");
         DCD = uvm_reg_field::type_id::create("DCD");
         RI = uvm_reg_field::type_id::create("RI");
         RTS = uvm_reg_field::type_id::create("RTS");
         DTR = uvm_reg_field::type_id::create("DTR");

         LOOPBACK.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         DCD.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         RI.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         RTS.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         DTR.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: IIR_reg
   // 
   //--------------------------------------------------------------------

   class IIR_reg extends uvm_reg;
      `uvm_object_utils(IIR_reg)

      uvm_reg_field TIED1; 
      uvm_reg_field TIED0; 
      uvm_reg_field STATUS; 
      uvm_reg_field PENDING_IRQ; 


      // Function: new
      // 
      function new(string name = "IIR_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         TIED1 = uvm_reg_field::type_id::create("TIED1");
         TIED0 = uvm_reg_field::type_id::create("TIED0");
         STATUS = uvm_reg_field::type_id::create("STATUS");
         PENDING_IRQ = uvm_reg_field::type_id::create("PENDING_IRQ");

         TIED1.configure(this, 2, 6, "RO", 0, 2'b11, 1, 0, 0);
         TIED0.configure(this, 2, 4, "RO", 0, 2'b00, 1, 0, 0);
         STATUS.configure(this, 3, 1, "RO", 0, 3'b000, 1, 0, 0);
         PENDING_IRQ.configure(this, 1, 0, "RO", 0, 1'b1, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: LSR_reg
   // 
   //--------------------------------------------------------------------

   class LSR_reg extends uvm_reg;
      `uvm_object_utils(LSR_reg)

      uvm_reg_field ERROR; 
      uvm_reg_field TX_EMPTY; 
      uvm_reg_field TX_FIFO_IS_EMPTY; 
      uvm_reg_field BREAK_INDICATION; 
      uvm_reg_field FRAMING_ERROR; 
      uvm_reg_field PARITY_ERROR; 
      uvm_reg_field OVERRUN_ERROR; 
      uvm_reg_field DATAREADY; 


      // Function: new
      // 
      function new(string name = "LSR_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ERROR = uvm_reg_field::type_id::create("ERROR");
         TX_EMPTY = uvm_reg_field::type_id::create("TX_EMPTY");
         TX_FIFO_IS_EMPTY = uvm_reg_field::type_id::create("TX_FIFO_IS_EMPTY");
         BREAK_INDICATION = uvm_reg_field::type_id::create("BREAK_INDICATION");
         FRAMING_ERROR = uvm_reg_field::type_id::create("FRAMING_ERROR");
         PARITY_ERROR = uvm_reg_field::type_id::create("PARITY_ERROR");
         OVERRUN_ERROR = uvm_reg_field::type_id::create("OVERRUN_ERROR");
         DATAREADY = uvm_reg_field::type_id::create("DATAREADY");

         ERROR.configure(this, 1, 7, "RC", 0, 1'b0, 0, 0, 0);
         TX_EMPTY.configure(this, 1, 6, "RC", 0, 1'b0, 0, 0, 0);
         TX_FIFO_IS_EMPTY.configure(this, 1, 5, "RC", 0, 1'b0, 0, 0, 0);
         BREAK_INDICATION.configure(this, 1, 4, "RC", 0, 1'b0, 0, 0, 0);
         FRAMING_ERROR.configure(this, 1, 3, "RC", 0, 1'b0, 0, 0, 0);
         PARITY_ERROR.configure(this, 1, 2, "RC", 0, 1'b0, 0, 0, 0);
         OVERRUN_ERROR.configure(this, 1, 1, "RC", 0, 1'b0, 0, 0, 0);
         DATAREADY.configure(this, 1, 0, "RC", 0, 1'b0, 0, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: RXTXBUF_reg
   // 
   //--------------------------------------------------------------------

   class RXTXBUF_reg extends uvm_reg;
      `uvm_object_utils(RXTXBUF_reg)

      rand uvm_reg_field DATA; 


      // Function: new
      // 
      function new(string name = "RXTXBUF_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         DATA = uvm_reg_field::type_id::create("DATA");

         DATA.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: uart16550_registers
   // 
   //--------------------------------------------------------------------

   class uart16550_registers extends uvm_reg_block;
      `uvm_object_utils(uart16550_registers)

      rand RXTXBUF_reg RXTXBUF; 
      rand IER_reg IER; 
      rand IIR_reg IIR; 
      rand FCR_reg FCR; 
      rand LCR_reg LCR; 
      rand MCR_reg MCR; 
      rand LSR_reg LSR; 
      rand MSR_reg MSR; 

      uvm_reg_map uart16550_registers_map; 


      // Function: new
      // 
      function new(string name = "uart16550_registers");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         RXTXBUF = RXTXBUF_reg::type_id::create("RXTXBUF");
         RXTXBUF.configure(this);
         RXTXBUF.build();

         IER = IER_reg::type_id::create("IER");
         IER.configure(this);
         IER.build();

         IIR = IIR_reg::type_id::create("IIR");
         IIR.configure(this);
         IIR.build();

         FCR = FCR_reg::type_id::create("FCR");
         FCR.configure(this);
         FCR.build();

         LCR = LCR_reg::type_id::create("LCR");
         LCR.configure(this);
         LCR.build();

         MCR = MCR_reg::type_id::create("MCR");
         MCR.configure(this);
         MCR.build();

         LSR = LSR_reg::type_id::create("LSR");
         LSR.configure(this);
         LSR.build();

         MSR = MSR_reg::type_id::create("MSR");
         MSR.configure(this);
         MSR.build();

         uart16550_registers_map = create_map("uart16550_registers_map", 'h0, 1, UVM_LITTLE_ENDIAN);
         default_map = uart16550_registers_map;

         uart16550_registers_map.add_reg(RXTXBUF, 'h0, "RW");
         uart16550_registers_map.add_reg(IER, 'h1, "RW");
         uart16550_registers_map.add_reg(IIR, 'h2, "RO");
         uart16550_registers_map.add_reg(FCR, 'h8, "WO");
         uart16550_registers_map.add_reg(LCR, 'h3, "RW");
         uart16550_registers_map.add_reg(MCR, 'h4, "WO");
         uart16550_registers_map.add_reg(LSR, 'h5, "RO");
         uart16550_registers_map.add_reg(MSR, 'h6, "RO");

         lock_model();
      endfunction
   endclass


endpackage
